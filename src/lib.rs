mod lalg;
mod op;

pub use lalg::Vec2;
pub use lalg::Vec3;
pub use lalg::Vec4;
pub use lalg::Mat4x4;
pub use lalg::Mat2x2;
pub use op::*;


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn matrix_ops() {


        let v = Mat4x4 { m:
        [1.0, 1.0, 1.0, 0.0,
            1.0, 1.0, 1.0, 0.0,
            1.0, 1.0, 1.0, 0.0,
            1.0, 1.0, 1.0, 1.0] };

        let A = Mat4x4 { m:
        [1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            -1.0,-1.0,-1.0, 1.0] };

        let v0 = Mat4x4 { m:
        [1.0, 1.0, 1.0, 0.0,
            1.0, 1.0, 1.0, 0.0,
            1.0, 1.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0] };

        assert_eq!(v*A,v0);

        let A = Mat4x4 { m: [7.0,  2.0,  9.0, 2.0,
            0.0,  3.0,  6.0, 13.0,
            5.0,  12.0, 2.0, 90.0,
            21.0, 8.0,  3.0, 2.0] };
        let B = Mat4x4 { m: [8.0,  90.0,  1.0, 22.0,
            34.0, 6.0,   8.0, 12.0,
            32.0, 123.0, 2.0, 11.0,
            14.0, 9.0,   0.0, 100.0] };
        let C = Mat4x4 { m: [440.0,  1767.0, 41.0,  477.0,
            476.0,  873.0,  36.0,  1402.0,
            1772.0, 1578.0, 105.0, 9276.0,
            564.0,  2325.0, 91.0,  791.0] };

        assert_eq!(A*B,C);

        assert!((&Mat4x4::identity() * &Mat4x4::identity()) == Mat4x4::identity());

        assert!((&Mat4x4::identity() + &Mat4x4::identity()) == Mat4x4 { m: [2.0, 0.0, 0.0, 0.0,
            0.0, 2.0, 0.0, 0.0,
            0.0, 0.0, 2.0, 0.0,
            0.0, 0.0, 0.0, 2.0] } );
        assert!((&Mat4x4::identity() - &Mat4x4::identity()) == Mat4x4 { m: [0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0] } );
        assert!((&Mat4x4::identity() * &Mat4x4::scale(2.0)) == Mat4x4 { m: [2.0, 0.0, 0.0, 0.0,
            0.0, 2.0, 0.0, 0.0,
            0.0, 0.0, 2.0, 0.0,
            0.0, 0.0, 0.0, 1.0] } );
        assert_eq!((&Mat4x4::identity() * &Mat4x4::translate(&Vec3{v:[1.0, 2.0, 3.0]})), Mat4x4 {m: [1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            1.0, 2.0, 3.0, 1.0] } );

        let m = Mat4x4{m: [1.1, 2.1, 3.1, 4.1,
            1.2, 2.2, 3.2, 4.2,
            1.3, 2.3, 3.3, 4.3,
            1.4, 2.4, 3.4, 4.4]};
        assert!( m.col(0) == Vec4{ v:[1.1, 1.2, 1.3, 1.4] } );
        assert!( m.col(1) == Vec4{ v:[2.1, 2.2, 2.3, 2.4] } );
        assert!( m.col(2) == Vec4{ v:[3.1, 3.2, 3.3, 3.4] } );
        assert!( m.col(3) == Vec4{ v:[4.1, 4.2, 4.3, 4.4] } );
        assert!( m.row(0) == Vec4{ v:[1.1, 2.1, 3.1, 4.1] } );
        assert!( m.row(1) == Vec4{ v:[1.2, 2.2, 3.2, 4.2] } );
        assert!( m.row(2) == Vec4{ v:[1.3, 2.3, 3.3, 4.3] } );
        assert!( m.row(3) == Vec4{ v:[1.4, 2.4, 3.4, 4.4] } );

        //assert!( ( &(&Mat4x4::rot_z(f32::consts::PI * 0.5) * &Vec4{ v: [ 1.0, 1.0, 0.0, 0.0] }) - &Vec4{ v: [-1.0, 1.0, 0.0, 0.0] }).len_sq() < 0.0000000000001 );
        //assert!( ( &(&Mat4x4::rot_x(f32::consts::PI * 0.5) * &Vec4{ v: [ 0.0, 1.0, 1.0, 0.0] }) - &Vec4{ v: [ 0.0,-1.0, 1.0, 0.0] }).len_sq() < 0.0000000000001 );
        //assert!( ( &(&Mat4x4::rot_y(f32::consts::PI * 0.5) * &Vec4{ v: [ 1.0, 0.0, 1.0, 0.0] }) - &Vec4{ v: [ 1.0, 0.0,-1.0, 0.0] }).len_sq() < 0.0000000000001 );

    }

    #[test]
    fn vec_ops() {
        assert!( &Vec4{ v: [1.0, 2.0, 3.0, 4.0] } + &Vec4 { v: [4.0, 3.0, 2.0, 1.0] } == Vec4{ v: [5.0, 5.0, 5.0, 5.0] } );
        assert!( &Vec4{ v: [1.0, 1.0, 1.0, 1.0] } - &Vec4 { v: [1.0, 1.0, 1.0, 1.0] } == Vec4{ v: [0.0, 0.0, 0.0, 0.0] } );
        assert!( Vec4::dot(&Vec4{ v: [1.0, 0.0, 1.0, 0.0] }, &Vec4{ v: [0.0, 1.0, 0.0, 1.0] }) == 0.0 );
        assert!( Vec4::dot(&Vec4{ v: [1.0, 2.0, 3.0, 4.0] }, &Vec4{ v: [4.0, 3.0, 2.0, 1.0] }) == (1*4+2*3+3*2+4*1) as f32 );
    }

}





